## Spring Core


#### 1. Scope бина
* singleton. Создается один единственный объект в контейнере. Значение по умоланию 
* prototype. Возможность создать несколько объектов
* request. Создание объекта при каждом HTTP-запросе
* session. Создается объект на каждую HTTP сессию
* global-session. Создаётся один экземпляр бина на каждую глобальную HTTP сессию

#### 2. Способы конфигурации Spring
* XML based configration
* Annotation based configuration
* Java based configuration

#### 3. `@Autowired`, `@Qualifier`, `@Primary`
`@Autowired` находит подходящее значение по типу. `@Qualifier` применяется в случаях, когда по типу подходит несколько значений, поэтому невозможно определить нужное значение с помощью `@Autowired`. `@Primary` используется над оперделенным значением, которое нужно заинжектить, это как значение по умолчанию.

#### 4. В чем отличие сквозной функциональности и АОП? 
Сквозная функционасть (Cross-cutting concern) – это функциональность, рассеянная по всему исходному коду ПО, систематически независимая от предметной области. АОП предоставляет возможность вызывать код сквозных функций без изменения исходного кода программы в определенный момент работы программы.

#### 5. `ApplicationContext` vs `BeanFactory`
Оба являются IoC контейнерами. `BeanFactory` обеспечивает базовую функциональность. `ApplicationContext` это sub-interface `BeanFactory` и соответственно расширяет функциональность последнего. 
Различия: 
1. `BeanFactory` поддерживает ленивую загрузку, то есть он загружает бины по требованию, в то время как `ApplicationContext` загружает все бины сразу. Это значит, что `BeanFactory` потребляет меньше памяти.
2. `ApplicationContext` поддерживает внедрение зависимостей на основе аннотаций, а также легкую интеграцию с Spring AOP, а также другой полезный функционал. У `BeanFactory` этого нет 

#### 6. `AnnotationConfigApplicationContext` и `ClassPathXmlApplicationContext`
`ApplicationContext context = new AnnotationConfigApplicationContext(AccountConfig.class);`
`ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext/user-bean-config.xml");`

#### 7. Как решить циклическую зависимость? Когда BeanA хочет заижектить BeanB, а BeanB хочет заинжектить BeanA.
1. Redesign
2. Использовать внедрение сеттера (или внедрение поля) вместо внедрения конструктора. Таким образом, Spring создает bean-компоненты, но зависимости не внедряются до тех пор, пока они не потребуются. 
3. Использовать `@Lazy`. Внедряеммый компонент создатся только когда он непосредственно будет нужен: 
`@Component
public class CircularDependencyA {

    private CircularDependencyB circB;

    @Autowired
    public CircularDependencyA(@Lazy CircularDependencyB circB) {
        this.circB = circB;
    }
} 
`

#### 8. Как работает `@Transactional`?


#### 9. Этапы поднятия контекста.
https://habr.com/ru/post/222579/

#### 10. Виды автоматического связывания
* По имени, autowire byName,
* По типу, autowire byType,
* Через конструктор, autowire by constructor

#### 11. Bean life cycle
(annotated/xml)BeanDefinitionReader - сканирует xml и все что там видит переводит в BeanDefinition. BeanDefinition хранит в себе информацию про бины. Контейнер  отвечает за создание и хранение всех бинов.

1. Приходит `BeanDefenitionReader` в контекст, считывает декларации бинов и кладет их в `BeanDefenition`. `BeanDefenitions` это такая мапа, где хранится id бина, есть ли у него init-метод и все остальные прописанные подробности бина 
2. Далее `BeanFactory` создает по нашим классам и `BeanDefenitions` объекты и помещает их в `IoC Container`. Важное замечание, что все бины-singletons создаются сразу при поднятии контекста и складываются в контейнер. А все prototypes создаются когда они нужны и не хранятся в контейнере. Это  причина по которой destroy-метод для prototype-бина не будет работать.
3. `BeanPostProcessor` позволяет настроить наши бины до того как они попали в контейнер. Это интерефейс, у которого есть два метода: `postProcessorBeforeInitialization` и `postProcessorAfterinitialization`. Между ними вызывается init-метод (@PostConstruct если описываем аннотации с помощью аннотирования). Зачем нужен init-метод, если есть конструктор? Если в конструкторе мы хотим обратиться к каким-то вещам (к полю, например), которые должен настроить Spring, их еще нет. То есть, спринг использует конструктор чтобы создать объект и только потом настраивает объект. 
4. `ApplicationListener` умеет слушать контекст спринга. Он используется как третий конструктор в трехфазовом конструкторе. Используется с помощью аннотации @AfterProxy.
5. `BeanFactoryPostProcessor` позволяет настраивать BeanDefenitions до того как создаются бины. Работает до `BeanPostProcessor`
6. `ClassPathBeanDefinitionScanner` ищет все бины аннотированные аннотацией @Component, или то, что включает в себя @Component


#### 12. Какие могут возникнуть проблемы, если применить @Autowired над полями?

#### 13. Что такое `EntityManager`? 
      
## Spring MVC и немного REST

#### 1. DispatcherServlet
Каждый веб-запрос, который должен обрабатывать Spring MVC проходит через DispatcherServlet, то есть он является единой точкой входа для приложения. DispatcherServlet может делегировать обработкузапроса контроллеру, то есть классу помеченому аннотацией @Controller. По своей сути является обычным сервлетом, наследуется от HttpServlet. Создается при запуске приложения, а не при первом запросе к приложению. Это связано с тем, что диспетчер сервлетов сопостовляет запросы контроллерам и все такое, и это занимает время, поэтому лучше сделать это до получения первого запроса, а не во время обработки первого запроса. Настраивается с помощью web.xml. 

#### 2. `@RequestMapping`
Раньше ипользовалась для методов с указанием http-метода, который будет обрабатывать запрос. Для методов появились аннотации @GetMapping, @DeleteMapping, @PutMappingn и т.д. Сейчас используется на уровне класса для описания URL 

#### 3. `@RequestParam` и `@PathVariable`
@RequestParam используется для обработки параметра из http-запроса.       
@PathVariable извлекает данные из URL

#### 4. `@ResponceBody` и `@RequestBody`
Аннотация `@ResponseBody` ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется `@RestController`. Обычные методы возвращают Model, а методы аннотированные `@ResponseBody` возвращают объекты, которые конвертируются в медиа-файлы (например, в JSON) с помощью HttpMessageConverter.           
Вы можете использовать аннотацию `@RequestBody` на параметре метода, для того чтобы тело запроса конвертировалось в этот параметр.

#### 5. Что такое View? 
Используется для отображения данных пользователю. Это может быть JSP, Thymeleaf

#### 6. `@RestController` 
`@RestController` ставится на класс-контроллер вместо `@Controller`. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций `@Controller` и `@RequestBody`.

#### 7. Что такое `HttpMessageConverter`?
`HttpMessageConverter` конвертирует запрос в объект и наоборот.       
Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.       
В этом случае DispatcherServlet не использует Model и View.         
В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.            

#### 8. `RestTemplate` vs `WebClient`
`RestTemplate` это синхронный клиент для выполнения HTTP-запросов. `RestTemplate` отправляет запрос, и простаивает, ожидая пока будет доступен ответ, из-за чего является намного медлительнее, чем `WebClient`, который получает "уведомление" о том, что ответ доступен.

#### 9. Асинхронные запросы 
Асинхронный запрос позволяет выполнить нам "тяжеловесный" запрос, например извлечение большого количества данных из бд, не блокируя выполнение основного потока. То есть наш "тяжеловесный" поток будет выполняться, но приложение не будет простаивать, дожидаясь пока запрос выполнится, а продолжит свою нормальную работу.

#### 10. WebSockets
WebSockets — это двунаправленное, **постоянное** соединение между веб-браузером и сервером. Как только соединение WebSocket установлено, соединение остается открытым до тех пор, пока клиент или сервер не решит закрыть это соединение. Это быстрее, чем http-запросы, так как избегает все "все рукопожатия" при каждой передаче данных.     
Типичным вариантом использования может быть ситуация, когда в приложении несколько пользователей общаются друг с другом, например, в чате.    

## Spring Boot

#### 1. Что нам дает Spring Boot?
* Встроенный сервер-приложение - контейнера сервлетов (Tomcat)
* Авто-кнфигурация
* Страртеры

#### 2. Какие аннотации включены в `@SpringBootApplication`?
* `@Configuration`
* `@EnableAutoConfiguration`
* `@ComponentScan`

#### 3. Что такое стартеры?
Эта такая зависимоть, которая содержит в себе другие зависимости. В итоге вместо того чтобы добавить несколько зависимостей, мы добавляем одну, которая содержит в себе 
список нужных нам зависимостей.
Также благодаря стартерам у нас настраивается авто-конфигурация. 

#### 4. Есть разница если мы используем starter'ы илии пропишем все зависимости вручную, кроме того что изменится количество строк?
У стартеров есть автоконфигурация. Поэтому благодаря стартерам нам не надо настраивать конфигурацию вручную.

#### 5. Как создать свой стартер?
Краеугольным камнем инфраструктуры Spring Boot являются __AutoConfiguration-классы__, которые Spring Boot находит при запуске приложения и использует для автоматического создания и конфигурирования бинов.

#### 6. `@ComponentScan`, `@Import`
С помощью `@ComponentScan` указывается место, в котором нужно искать бины для создания. Если место не указано, то сканироваться будет текущий пакет.          
`@Import` указывает конкретное место, конкретный класс, откуда мы хотим взять бины.

#### 7. `@Component`
Помечаем класс, который хотим собрать в бин. 

#### 8. `@Component` vs `@Bean`
1. `@Component` auto detects and configures the beans using classpath scanning whereas `@Bean` explicitly declares a single bean, rather than letting Spring do it automatically.
2.  `@Component` is a class level annotation whereas `@Bean` is a method level annotation and name of the method serves as the bean name.
3.  `@Component` need not to be used with the `@Configuration` annotation where as `@Bean` annotation has to be used within the class which is annotated with `@Configuration`.

#### 9. `@Service`, `@Repository`
Помимо `@Component` в обоих аннотациях, в `@Repository` зашита обработка исключений. В `@Service` нет дополнительных функций, это просто маркер, что этот класс содержит бизнес-логику. 

#### 10. Differences between `applicationContext.xml` and `spring-servlet.xml` in Spring
In short, `applicationContext` is the central interface in Spring. It provides configuration information for an application. `spring-servlet.xml`is part of the Spring MVC framework. We declare in this file the component scans for controllers.


