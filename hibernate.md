#### 1. Что такое `ORM`?
ORM (Object-Relational Mapping) - технология программирования, которая позволяет предствавлять БД в виде сущностей объектно-ориентированного программирования.

#### 2. Что такое `JPA`?
JPA (Java Persistence API) - это спецификация которая описывает какими средствами мы можем связать БД и сущности ООП.

#### 3. Что такое `Hibernate`?
Hibernate - это реализация JPA. 

#### 4. Что такое проблема `n+1` и как она решается в Hibernate?


#### 5. Стратегии наследования в Hibernate
__depricated:__  _1. Одна таблица для каждого класса.   
Допустим, есть какой-то базовый класс. От него наследуются два класса. Эти два класса будут отображением двух таблиц в бд. Чтобы технически это провернуть 
нужно базовый класс пометить аннотацией `@MappedSuperclass`, а производные классы традиционным `@Entity`. Тогда в табличках, которые соответсвуют производным классам, будут колонки соответсвующие полями как из производного класса, так и из базового. Если мы хотим чтобы название колонки в таблице отличалось от имени поля в родительском классе, то для этого есть аннотация `@AttributeOverride`, которая применима для данной стратегии._    

2. Одна таблица для каждого класса с объединениями (UNION).   
Аналогична пункту 1, но имеет ряд преимуществ. Для реализации данной стратегии следует базовый класс пометить аннотациями `@Entity` и `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`. Также в базовом классе необходим идентификатор.
_Недостатки:_ появляются проблемы с генераторами ключей и другие проблемы целостности данных.   
_Не рекомендуется использовать._

3. Единая таблица для всей иерархии классов.   
Нужна если мы имеем иерархию классов, которую мы хотим отобразить на одну таблицу. Над базовым классом используем аннотации `@Entity` и `Inheritance (strategy = InheritanceType.SINGLE_TABLE)`. Также есть одна особенность реализации такой стратегии. Она заключается в том, что для каждого запроса будет определяться конкретный подклас с помощью `селектора`. Поэтому нужно базовый класс пометить аннотацией `@DiscriminatorColumn(name = "some_column_name")`. Каждый класс иерархии может указать свое значение селектора с помощью аннотации `@DiscriminatorValue("name")`. Базовому классу также необхид идентификатор.   
_Преимущества:_ избегаем джоинов   
_Недостатки:_ теряем третью нормальную форму и не можем указать NOT NULL (???)    
4. Одна таблица для каждого класса с использованием соединений (JOIN).   
Каждый класс иерархии соответсвует таблице в бд. Базовый класс должен содержать аннотацию `@Entity`, `@inheritance (strategy = InheritanceType.JOINED)`, должен содержать идентификатор.    
_Преимущества:_ сохраняем третью нормальную форму, можем указать NOT NULL   
_Недостатки:_ Появляются JOIN в запросах

#### 6. Отношения композиции.
_OneToOne_ не рекомендуется использовать, так как у нас появляется неоправданный JOIN. Для отображения композиции в общую таблицу следует использовать `@Embedable` (над полем) или `@Embeded` (над классом). Эти аннотации взаимозаменяемы.

#### 7. Entity Manager
Каждый экземпляр Entity Manager (EM) определяет сеанс взаимодействия с БД.

#### 8. GenerationType
Генераторы нужны для того, чтобы определять каким образом наши сущности будут получать значения. 

* __GenerationType.AUTO__ - выбор осуществляется на основании диалекта. Не самый лучший способ, так как лучше определять явно стратегию, нежели неявно) 
* __GenerationType.IDENTITY__ 
* __GenerationType.SEQUENCE__
* __GenerationType.TABLE__

#### 9. Fetch стратегии
1. LAZY - данные подгружаются при первом запросе к ним
2. EAGER - данные подгружаются при создании объекта

#### 10. Виды кэша в Hibernate
* first-level cash - кэширует данные одной транзакции
* second-level cash - кэширует данные дальше чем одна транзакция

#### 11. @Transient
Поле помеченное такой аннотацией не будет добавлено в БД.
