#### 1. Что такое `ORM`?
ORM (Object-Relational Mapping) - технология программирования, которая позволяет предствавлять БД в виде сущностей объектно-ориентированного программирования.

#### 2. Что такое `JPA`?
JPA (Java Persistence API) - это спецификация которая описывает какими средствами мы можем связать БД и сущности ООП.

#### 3. Что такое `Hibernate`?
Hibernate - это реализация JPA. 

#### 4. Что такое проблема `n+1` и как она решается в Hibernate?
Проблема N + 1 возникает, когда фреймворк доступа к данным выполняет N дополнительных SQL-запросов для получения тех же данных, которые можно получить при выполнении одного SQL-запроса. Проблема заключается в выполнении множества дополнительных запросов, которые в сумме выполняются уже существенное время, влияющее на быстродействие.         
          
_Эти дополнительные SQL select-ы нужны для заполнения поля, ссылающегося на другую сущность(и).     
Здесь N — количество объектов, возвращаемых первым явным select-ом. Для каждого из них надо заполнить поле, вот и получается еще N select-ов._          
       
Для решения проблемы использум не простой select, а select с join fetch, который преобразуется в SQL с inner join. Рекомендуется также всегда выставлять fetch = FetchType.LAZY  — на те случаи, когда заполненное поле Topic не нужно.         
         

#### 5. Стратегии наследования в Hibernate
__depricated:__  _1. Одна таблица для каждого класса.   
Допустим, есть какой-то базовый класс. От него наследуются два класса. Эти два класса будут отображением двух таблиц в бд. Чтобы технически это провернуть 
нужно базовый класс пометить аннотацией `@MappedSuperclass`, а производные классы традиционным `@Entity`. Тогда в табличках, которые соответсвуют производным классам, будут колонки соответсвующие полями как из производного класса, так и из базового. Если мы хотим чтобы название колонки в таблице отличалось от имени поля в родительском классе, то для этого есть аннотация `@AttributeOverride`, которая применима для данной стратегии._    

2. Одна таблица для каждого класса с объединениями (UNION).   
Аналогична пункту 1, но имеет ряд преимуществ. Для реализации данной стратегии следует базовый класс пометить аннотациями `@Entity` и `@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)`. Также в базовом классе необходим идентификатор.
_Недостатки:_ появляются проблемы с генераторами ключей и другие проблемы целостности данных.   
_Не рекомендуется использовать._

3. Единая таблица для всей иерархии классов.   
Нужна если мы имеем иерархию классов, которую мы хотим отобразить на одну таблицу. Над базовым классом используем аннотации `@Entity` и `Inheritance (strategy = InheritanceType.SINGLE_TABLE)`. Также есть одна особенность реализации такой стратегии. Она заключается в том, что для каждого запроса будет определяться конкретный подклас с помощью `селектора`. Поэтому нужно базовый класс пометить аннотацией `@DiscriminatorColumn(name = "some_column_name")`. Каждый класс иерархии может указать свое значение селектора с помощью аннотации `@DiscriminatorValue("name")`. Базовому классу также необхид идентификатор.   
_Преимущества:_ избегаем джоинов   
_Недостатки:_ теряем третью нормальную форму и не можем указать NOT NULL (???)    
4. Одна таблица для каждого класса с использованием соединений (JOIN).   
Каждый класс иерархии соответсвует таблице в бд. Базовый класс должен содержать аннотацию `@Entity`, `@inheritance (strategy = InheritanceType.JOINED)`, должен содержать идентификатор.    
_Преимущества:_ сохраняем третью нормальную форму, можем указать NOT NULL   
_Недостатки:_ Появляются JOIN в запросах

#### 6. Отношения композиции.
_OneToOne_ не рекомендуется использовать, так как у нас появляется неоправданный JOIN. Для отображения композиции в общую таблицу следует использовать `@Embedable` (над полем) или `@Embeded` (над классом). Эти аннотации взаимозаменяемы.

#### 7. Entity Manager
Каждый экземпляр Entity Manager (EM) определяет сеанс взаимодействия с БД.

#### 8. Стратегии генерации первичного ключа
Генераторы нужны для того, чтобы определять каким образом наши сущности будут получать значения. 

* __GenerationType.AUTO__ - выбор осуществляется самим Hibernate, выбор осуществляется на основании диалекта. Не самый лучший способ, так как лучше определять стратегию явно 
* __GenerationType.IDENTITY__ - первичный ключ будет генерироваться на основании типа данных identity, который встроен в БД
* __GenerationType.SEQUENCE__ - используется последовательность - специальный объект БД для генерации уникального числа
* __GenerationType.TABLE__ - используется отдельная таблица для генерации и хранения первичного ключа. Имеет наихудшую производительность, рекомендуетсяя избегать

#### 9. Fetch стратегии
1. LAZY - данные подгружаются при первом запросе к ним
2. EAGER - данные подгружаются при создании объекта

#### 10. Виды кэша в Hibernate
* Кеш первого уровня (first-level cache) - этот кеш привязан к объекту сессии. Hibernate использует его по  умолчанию и его нельзя отключить.
* Кеш второго уровня (second-level cache) - этот кеш привязан к объекту фабрики сессий, поэтому у него шире функционал. У Hibernate нет своей реализации такого кеша, поэтому его надо дополнительно настраивать. Также чтение из кеша второго уровня происходит если объект не был найден в кеше первого уровня. Кэш второго уровня не хранит сами объекты, а лишь информацию об объектах (в структуре похожей на мапу). По умолчанию зависимости класса не ешируются, но это можно настроить.
* Кеш запросов (query cache) - название говорит само за себя. В отличии от кеша второго уровня в качестве ключа к данным кеша выступает не идентификатор объекта, а совокупность параметров запроса. А сами данные - это объекты удовлетворяющие параметрам запроса.

#### 11. Различие методов `get()` и `load()`.

#### 12. `@Transient`
Поле помеченное такой аннотацией не будет добавлено в БД.

#### 13. Требования к классу Entity
1. Должен быть помечен аннотацией `@Entity`
2. Должен иметь конструктор без аргументов
3. Класс не должен быть final
4. Должен иметь поле помеченное аннотацией `@Id`.

#### 14. `@Transactional`
https://easyjava.ru/spring/spring-data-access/izolyaciya-i-rasprostranenie-tranzakcij-v-spring/


