# Common question

#### 1. Для чего нужны системы контроля версий? 
Системы контроля версий сохраняют разные версии файлов. Это дает нам возможность просмотреть историю измения файла, а также вернуть состояние файла к предыдущей версии. 

#### 2. Виды систем контроля версий
* **Локальная VCS**. В БД хранятся записи обо всех изменениях файлов. Позволяет откатиться к предыдущим изменениям, но является абсолютно локальной, что неудобно при работе в команде. Примером является _RCS_.
* **Централизованная VCS**. Все изменения файлов хранятся на едином сервере. Упрощает коллективную работу, так как сервес с исходным кодом доступен нескольким людям, но в случаее неисправности сервера, весь исходный код будет утерян, так как хранится в единственном экземпляре только на сервере.   Примеры — CVS, Subversion(SVN), Perforce.
* **Распределенная VCS**. Хранение кода стало более надежным, так как он хранится у каждого локально, что позволяет его восстановить из любой локальной копии. Mercurial, Bazaar, Darcs и Git.        
    
#### 3. SVN vs Git
* Git распределенная система контроля версий, SVN централизованная
* Git сохраняет метаданные об изменениях файла, SVN сохраняет сами файлы. Git экономит место и получается рабтает быстрее
* В Git проще процесс сливания веток, в SVN сложнее, конфликты приходится разруливать руками
* SVN проще Git'а в освоении

# Git

#### 1.  Модели/стратегии ветвления в Git
**GitHub Flow**           
1. Код в ветке master должен быть всегда рабочим и готовым к развертыванию в любое время. 
2. При разработкеновой функциональности создается новая ветка от master-ветки и дается ей понятное, говорящее название. Разработка новой функциональности ведется только в этой новой ветке.
3. После того как функционал написан, открыть pull request, после ревью и апрува код мержится в master.
4. Новая версия мастера тут же должна быть развернута на сервере.               
                   
**GitFlow**
1. От master ветки создается ветка development в которой ведется разработка. Master по-прежнему остается всегда рабочим.
2. От development-ветки может быть создано три типа веток: feature-ветка (разработка новой фнкциональности), release-ветка (после написания функционала в этой ветке ведется подготовка к релизу новой версии приложения и устранению дефектов), hotfix-ветка (быстрое утсранение дефектов обнаруженных в проде самими пользователями). Все мержится сразу в development и только потом в master.           
                
**The Forking Workflow**                
Обычно применяется для open-source разработки. Сущетвует оригинальный репозиторий. Тот кто хочет внеси изменения в этот репозиторию делают форк репозитория, и работает в дрегом репозиториии. Владелец оригинального репозитория вправе отклонить предлагаемые изменения. Или смержить их в оригинальный репозиторий. 

#### 2. Основные состояния файлов
_измененный_, _индексированный_, _зафиксированный_    
      
_You are changed file_, _git add_, _git commit_
   
#### 3. Merge vs Rebase
Обе комманды предназначены для внесения изменений из одной ветки в другую, но делают они это по-разному.            
`git merge` объединяет несколько веток, история коммитов остается в первозданном виде, добавляется только коммит слияния.           
`git rebase` повторно применяет коммиты поверх другой базовой ветки. По сути создаются совершенно новые коммиты, хоть и идентичные по содержанию со старыми. Старые тем временем удаляются.             
            
* При merge мы решаем возникшие конфликты в одном коммите слияния. При rebase мы проходимся по каждому коммиту, и разрешаем конфликты в каждом коммите.
                 
Git merge: 
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-merge.png "merge")

Git rebase: 
(P.S. из ветки feature сделан rebase ветки main)
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-rebase.png "rebase")

Еще про rebase.
Как делать не надо (из ветки main сделан rebase ветки feature):
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-rebase-BAD-practice.png "так делать не надо")


#### 4. cherry-peak
Позволяет забрать коммит из одной ветку и вставить ее в текущую. 

#### 5. Как из нескольких коммитов сделать одни? 
`git squash`

#### 6. interactive rebase
Инструмент для исправления коммитов.

#### 7. `git stash` и `git stash applye`
`git stash` — откладывает изменения         
`git stash applye` — возвращает отложенные изменения
