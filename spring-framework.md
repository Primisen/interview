## Spring Core
#### 1. Scope бина
* singleton. Создается один единственный объект в контейнере. Значение по умоланию 
* prototype. Возможность создать несколько объектов
* request. Создание объекта при каждом HTTP-запросе
* session. Создается объект на каждую HTTP сессию
* global-session. Создаётся один экземпляр бина на каждую глобальную HTTP сессию

#### 2. Виды автоматического связывания
Существует четыре вида связывания в спринг:

autowire byName,
autowire byType,
autowire by constructor,
autowiring by @Autowired and @Qualifier annotations

#### 3. @Autowired, @Qualifier, @Primary
@Autowired находит подходящее значение по типу. @Qualifier применяется в случаях, когда по типу подходит несколько значений, поэтому невозможно определить нужное значение с помощью @Autowired. 


#### 4. Bean life cycle


#### 2. ApplicationContext vs BeanFactory

#### 3. IoC и DI

#### 4. Какие могут возникнуть проблемы, если применить @Autowired над полями?

#### 5. Как решить циклическую зависимость? Когда BeanA хочет заижектить BeanB, а BeanB хочет заинжектить BeanA.

#### 6. Как работает аннотация `Transaction`?

#### 7. В чем отличие аннотации @Component и @Bean?

#### 8. Жизненый цикл бина.

#### 9. Этапы поднятия контекста.
https://habr.com/ru/post/222579/

#### 10. Какие scope есть у бинов?

## Spring MVC и немного REST

#### 1. DispatcherServlet
Каждый веб-запрос, который должен обрабатывать Spring MVC проходит через DispatcherServlet, то есть он является единой точкой входа для приложения. DispatcherServlet может делегировать обработкузапроса контроллеру, то есть классу помеченому аннотацией @Controller. По своей сути является обычным сервлетом, наследуется от HttpServlet. Создается при запуске приложения, а не при первом запросе к приложению. Это связано с тем, что диспетчер сервлетов сопостовляет запросы контроллерам и все такое, и это занимает время, поэтому лучше сделать это до получения первого запроса, а не во время обработки первого запроса. Настраивается с помощью web.xml. 

#### 2. `@RequestMapping`
Раньше ипользовалась для методов с указанием http-метода, который будет обрабатывать запрос. Для методов появились аннотации @GetMapping, @DeleteMapping, @PutMappingn и т.д. Сейчас используется на уровне класса для описания URL 

#### 3. `@RequestParam` и `@PathVariable`
@RequestParam используется для обработки параметра из http-запроса.       
@PathVariable извлекает данные из URL

#### 4. `@ResponceBody` и `@RequestBody`
Аннотация `@ResponseBody` ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется `@RestController`. Обычные методы возвращают Model, а методы аннотированные `@ResponseBody` возвращают объекты, которые конвертируются в медиа-файлы (например, в JSON) с помощью HttpMessageConverter.           
Вы можете использовать аннотацию `@RequestBody` на параметре метода, для того чтобы тело запроса конвертировалось в этот параметр.

#### 5. Что такое View? 
Используется для отображения данных пользователю. Это может быть JSP, Thymeleaf

#### 6. `@RestController` 
`@RestController` ставится на класс-контроллер вместо `@Controller`. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций `@Controller` и `@RequestBody`.

#### 7. Что такое `HttpMessageConverter`?
`HttpMessageConverter` конвертирует запрос в объект и наоборот.       
Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.       
В этом случае DispatcherServlet не использует Model и View.         
В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.            

#### 8. `RestTemplate` vs `WebClient`
`RestTemplate` это синхронный клиент для выполнения HTTP-запросов. `RestTemplate` отправляет запрос, и простаивает, ожидая пока будет доступен ответ, из-за чего является намного медлительнее, чем `WebClient`, который получает "уведомление" о том, что ответ доступен.

#### 9. Асинхронные запросы 
Асинхронный запрос позволяет выполнить нам "тяжеловесный" запрос, например извлечение большого количества данных из бд, не блокируя выполнение основного потока. То есть наш "тяжеловесный" поток будет выполняться, но приложение не будет простаивать, дожидаясь пока запрос выполнится, а продолжит свою нормальную работу.

#### 10. WebSockets
WebSockets — это двунаправленное, **постоянное** соединение между веб-браузером и сервером. Как только соединение WebSocket установлено, соединение остается открытым до тех пор, пока клиент или сервер не решит закрыть это соединение. Это быстрее, чем http-запросы, так как избегает все "все рукопожатия" при каждой передаче данных.     
Типичным вариантом использования может быть ситуация, когда в приложении несколько пользователей общаются друг с другом, например, в чате.    

## Spring Boot

#### 1. Что нам дает Spring Boot?
* Встроенный сервер-приложение - контейнера сервлетов (Tomcat)
* Авто-кнфигурация
* Страртеры

#### 2. Какие аннотации включены в `@SpringBootApplication`?
* `@Configuration`
* `@EnableAutoConfiguration`
* `@ComponentScan`

#### 3. Что такое стартеры?
Эта такая зависимоть, которая содержит в себе другие зависимости. В итоге вместо того чтобы добавить несколько зависимостей, мы добавляем одну, которая содержит в себе 
список нужных нам зависимостей.
Также благодаря стартерам у нас настраивается авто-конфигурация. 

#### 4. Есть разница если мы используем starter'ы илии пропишем все зависимости вручную, кроме того что изменится количество строк?
У стартеров есть автоконфигурация. Поэтому благодаря стартерам нам не надо настраивать конфигурацию вручную.

#### 5. Как создать свой стартер?
Краеугольным камнем инфраструктуры Spring Boot являются __AutoConfiguration-классы__, которые Spring Boot находит при запуске приложения и использует для автоматического создания и конфигурирования бинов.

#### 6. 
