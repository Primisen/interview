#### 1. Сложность алгоритма
Обычно оценивают **по времени** выполнения **или** **по** используемой **памяти**.   
Как я поняла, обычно сложность алгоритмов сортировки и поиска оценивают по времени.       
    
_n_ — количество элементов входных данных. Проще говоря, нужно понимать сколько нам нужно перебрать элементов, чтобы достигнуть нужного. Дальше со временем и памятью это навороты из математики 
    
**O(n) — линейная сложность**       
Например, чтобы найти максимальный элемент в не отсортированном массиве, нужно пройтись _по всем_ элементам этого массива. 

**O(log(n)) — логарифмическая сложность**            
Логарифмом числа b по основанию a называют показатель степени с основанием a, равной b. То есть, **попросту говоря, логарифм — это степень, в которую нужно возвести a для получения b**. По идее, теперь можно понять почему алгоритм с логарифмической сложностью быстрее: логарифм от n с основанием 2 меньше, чем n и n2        
       
**O(n log(n)) — линейно-логарифмическая сложность**      
O(n*log(n))
       
**O(n2) — квадратичная сложность**    
По идее тут все понятно      


## Алгоритмы сортировки

#### 1. Сложность алгоритмов сортировки
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D0%BE%D0%B2%20%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B8.png)

#### 2. Пузырьковая сортировка
Сравниваем соседние элементы, если они расположены не по порядку, то меняем их местами. Так проходимся по всему массиву несколько раз пока не отсортируем весь массив. Прост в понимании, но зато очень непроизводительный. 

#### 3. Быстрая сортировка
Выбирается случайный элемент, вокруг которого мы сортируем остальные элементы: меньшие перемещаем левее этого элемента, большие ставим правее. Далее рекурсивно мы сортируем таким же способом левую и правую часть от этого элемента.

#### 4. Сортировка вставками
В общем, по порядку идем по элементам массива. Берем элемент и сразу же ставим его в нужную позицию в массиве. Так массив условно делится на отсортированную часть и несортированную.

![](https://github.com/Primisen/interview/blob/master/pictures/%D1%81%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B2%D1%81%D1%82%D0%B0%D0%B2%D0%BA%D0%B0%D0%BC%D0%B8.gif)

#### 5. Сортировка слиянием
Массив делится на подмассивы до тех пор, пока каждый подмассив не будет содержать по одному элементу. Далее происходит слияние. Каждый подмассив сортируется с соседним и сливается, образуя отсортированный подмассив из двух элементов. Далее каждый из этих подмассивов по два элемента снова сортируется с соседним и сливается и так до конца сортировки.

![](pictures/Merge-sort-.gif)

#### 6. Сортировка выбором
Условно делим массив на две части: отсортированную часть и неотсортированную. В неотсортированной части (при первой итерации это весь массив) находим _наименьший_ элемент и _меняем_ его с первым элементом. И так далее: снова в неотсортированном подмассиве ищем наименьший элемент и меняем его с первым элементом неотсортированного подмассива. 

![](pictures/selection-sort.gif)

#### 7. Какую сортировку Java использует по умолчанию? 
* Быструю сортировку.
* Параллельную сортировку (с Java 8)


## Алгоритмы поиска

#### 1. Линейный поиск
Все элементы поочередно, линейно сравниваются с искомым

#### 2. Бинарный поиск
Работает только на отсортированной структуре данных.            
Сравниваем средний элемент с искомым. Если средний элемент больше искомого, значит ищем в левой половине, там где элементы меньше, иначе ищем в правой половине от среднего. И так рекурсивно пока не надем нужное значение.
