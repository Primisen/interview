[Spring Framework](#Spring-Framework)    
[Git](#Git)

<details>
  <summary>Spring Framework</summary>

# Spring Framework
## Spring Core


#### 1. Scope бина
* singleton. Создается один единственный объект в контейнере. Значение по умоланию 
* prototype. Возможность создать несколько объектов
* request. Создание объекта при каждом HTTP-запросе
* session. Создается объект на каждую HTTP сессию
* global-session. Создаётся один экземпляр бина на каждую глобальную HTTP сессию

#### 2. Способы конфигурации Spring
* XML based configration
* Annotation based configuration
* Java based configuration

#### 3. `@Autowired`, `@Qualifier`, `@Primary`
`@Autowired` находит подходящее значение по типу. `@Qualifier` применяется в случаях, когда по типу подходит несколько значений, поэтому невозможно определить нужное значение с помощью `@Autowired`. `@Primary` используется над оперделенным значением, которое нужно заинжектить, это как значение по умолчанию.

#### 4. В чем отличие сквозной функциональности и АОП? 
Сквозная функционасть (Cross-cutting concern) – это функциональность, рассеянная по всему исходному коду ПО, систематически независимая от предметной области. АОП предоставляет возможность вызывать код сквозных функций без изменения исходного кода программы в определенный момент работы программы.

#### 5. `ApplicationContext` vs `BeanFactory`
Оба являются IoC контейнерами. `BeanFactory` обеспечивает базовую функциональность. `ApplicationContext` это sub-interface `BeanFactory` и соответственно расширяет функциональность последнего. 
Различия: 
1. `BeanFactory` поддерживает ленивую загрузку, то есть он загружает бины по требованию, в то время как `ApplicationContext` загружает все бины сразу. Это значит, что `BeanFactory` потребляет меньше памяти.
2. `ApplicationContext` поддерживает внедрение зависимостей на основе аннотаций, а также легкую интеграцию с Spring AOP, а также другой полезный функционал. У `BeanFactory` этого нет 

#### 6. `AnnotationConfigApplicationContext` и `ClassPathXmlApplicationContext`
`ApplicationContext context = new AnnotationConfigApplicationContext(AccountConfig.class);`
`ApplicationContext context = new ClassPathXmlApplicationContext("applicationcontext/user-bean-config.xml");`

#### 7. Как решить циклическую зависимость? Когда BeanA хочет заижектить BeanB, а BeanB хочет заинжектить BeanA.
1. Redesign
2. Использовать внедрение сеттера (или внедрение поля) вместо внедрения конструктора. Таким образом, Spring создает bean-компоненты, но зависимости не внедряются до тех пор, пока они не потребуются. 
3. Использовать `@Lazy`. Внедряеммый компонент создатся только когда он непосредственно будет нужен: 
`@Component
public class CircularDependencyA {

    private CircularDependencyB circB;

    @Autowired
    public CircularDependencyA(@Lazy CircularDependencyB circB) {
        this.circB = circB;
    }
} 
`

#### 8. Как работает `@Transactional`?


#### 9. Этапы поднятия контекста.
https://habr.com/ru/post/222579/

#### 10. Виды автоматического связывания
* По имени, autowire byName,
* По типу, autowire byType,
* Через конструктор, autowire by constructor

#### 11. Bean life cycle
(annotated/xml)BeanDefinitionReader - сканирует xml и все что там видит переводит в BeanDefinition. BeanDefinition хранит в себе информацию про бины. Контейнер  отвечает за создание и хранение всех бинов.

1. Приходит `BeanDefenitionReader` в контекст, считывает декларации бинов и кладет их в `BeanDefenition`. `BeanDefenitions` это такая мапа, где хранится id бина, есть ли у него init-метод и все остальные прописанные подробности бина 
2. Далее `BeanFactory` создает по нашим классам и `BeanDefenitions` объекты и помещает их в `IoC Container`. Важное замечание, что все бины-singletons создаются сразу при поднятии контекста и складываются в контейнер. А все prototypes создаются когда они нужны и не хранятся в контейнере. Это  причина по которой destroy-метод для prototype-бина не будет работать.
3. `BeanPostProcessor` позволяет настроить наши бины до того как они попали в контейнер. Это интерефейс, у которого есть два метода: `postProcessorBeforeInitialization` и `postProcessorAfterinitialization`. Между ними вызывается init-метод (@PostConstruct если описываем аннотации с помощью аннотирования). Зачем нужен init-метод, если есть конструктор? Если в конструкторе мы хотим обратиться к каким-то вещам (к полю, например), которые должен настроить Spring, их еще нет. То есть, спринг использует конструктор чтобы создать объект и только потом настраивает объект. 
4. `ApplicationListener` умеет слушать контекст спринга. Он используется как третий конструктор в трехфазовом конструкторе. Используется с помощью аннотации @AfterProxy.
5. `BeanFactoryPostProcessor` позволяет настраивать BeanDefenitions до того как создаются бины. Работает до `BeanPostProcessor`
6. `ClassPathBeanDefinitionScanner` ищет все бины аннотированные аннотацией @Component, или то, что включает в себя @Component


#### 12. Какие могут возникнуть проблемы, если применить @Autowired над полями?

#### 13. Что такое `EntityManager`? 
      
## Spring MVC и немного REST

#### 1. DispatcherServlet
Каждый веб-запрос, который должен обрабатывать Spring MVC проходит через DispatcherServlet, то есть он является единой точкой входа для приложения. DispatcherServlet может делегировать обработкузапроса контроллеру, то есть классу помеченому аннотацией @Controller. По своей сути является обычным сервлетом, наследуется от HttpServlet. Создается при запуске приложения, а не при первом запросе к приложению. Это связано с тем, что диспетчер сервлетов сопостовляет запросы контроллерам и все такое, и это занимает время, поэтому лучше сделать это до получения первого запроса, а не во время обработки первого запроса. Настраивается с помощью web.xml. 

#### 2. `@RequestMapping`
Раньше ипользовалась для методов с указанием http-метода, который будет обрабатывать запрос. Для методов появились аннотации @GetMapping, @DeleteMapping, @PutMappingn и т.д. Сейчас используется на уровне класса для описания URL 

#### 3. `@RequestParam` и `@PathVariable`
@RequestParam используется для обработки параметра из http-запроса.       
@PathVariable извлекает данные из URL

#### 4. `@ResponceBody` и `@RequestBody`
Аннотация `@ResponseBody` ставится на методы, которые работают с данными, а не с моделями. Ее не требуется указывать явно, если используется `@RestController`. Обычные методы возвращают Model, а методы аннотированные `@ResponseBody` возвращают объекты, которые конвертируются в медиа-файлы (например, в JSON) с помощью HttpMessageConverter.           
Вы можете использовать аннотацию `@RequestBody` на параметре метода, для того чтобы тело запроса конвертировалось в этот параметр.

#### 5. Что такое View? 
Используется для отображения данных пользователю. Это может быть JSP, Thymeleaf

#### 6. `@RestController` 
`@RestController` ставится на класс-контроллер вместо `@Controller`. Она указывает, что этот класс оперирует не моделями, а данными. Она состоит из аннотаций `@Controller` и `@RequestBody`.

#### 7. Что такое `HttpMessageConverter`?
`HttpMessageConverter` конвертирует запрос в объект и наоборот.       
Spring имеет несколько реализаций этого интерфейса, а вы можете создать свою.       
В этом случае DispatcherServlet не использует Model и View.         
В REST вообще не существует Model и View. Есть только данные, поставляемые контроллером, и представление ресурса, когда сообщение конвертируется из медиа-типа(json, xml...) в объект.            

#### 8. `RestTemplate` vs `WebClient`
`RestTemplate` это синхронный клиент для выполнения HTTP-запросов. `RestTemplate` отправляет запрос, и простаивает, ожидая пока будет доступен ответ, из-за чего является намного медлительнее, чем `WebClient`, который получает "уведомление" о том, что ответ доступен.

#### 9. Асинхронные запросы 
Асинхронный запрос позволяет выполнить нам "тяжеловесный" запрос, например извлечение большого количества данных из бд, не блокируя выполнение основного потока. То есть наш "тяжеловесный" поток будет выполняться, но приложение не будет простаивать, дожидаясь пока запрос выполнится, а продолжит свою нормальную работу.

#### 10. WebSockets
WebSockets — это двунаправленное, **постоянное** соединение между веб-браузером и сервером. Как только соединение WebSocket установлено, соединение остается открытым до тех пор, пока клиент или сервер не решит закрыть это соединение. Это быстрее, чем http-запросы, так как избегает все "все рукопожатия" при каждой передаче данных.     
Типичным вариантом использования может быть ситуация, когда в приложении несколько пользователей общаются друг с другом, например, в чате.    

## Spring Boot

#### 1. Что нам дает Spring Boot?
* Встроенный сервер-приложение - контейнера сервлетов (Tomcat)
* Авто-кнфигурация
* Страртеры

#### 2. Какие аннотации включены в `@SpringBootApplication`?
* `@Configuration`
* `@EnableAutoConfiguration`
* `@ComponentScan`

#### 3. Что такое стартеры?
Эта такая зависимоть, которая содержит в себе другие зависимости. В итоге вместо того чтобы добавить несколько зависимостей, мы добавляем одну, которая содержит в себе 
список нужных нам зависимостей.
Также благодаря стартерам у нас настраивается авто-конфигурация. 

#### 4. Есть разница если мы используем starter'ы илии пропишем все зависимости вручную, кроме того что изменится количество строк?
У стартеров есть автоконфигурация. Поэтому благодаря стартерам нам не надо настраивать конфигурацию вручную.

#### 5. Как создать свой стартер?
Краеугольным камнем инфраструктуры Spring Boot являются __AutoConfiguration-классы__, которые Spring Boot находит при запуске приложения и использует для автоматического создания и конфигурирования бинов.

#### 6. `@ComponentScan`, `@Import`
С помощью `@ComponentScan` указывается место, в котором нужно искать бины для создания. Если место не указано, то сканироваться будет текущий пакет.          
`@Import` указывает конкретное место, конкретный класс, откуда мы хотим взять бины.

#### 7. `@Component`
Помечаем класс, который хотим собрать в бин. 

#### 8. `@Component` vs `@Bean`
1. `@Component` auto detects and configures the beans using classpath scanning whereas `@Bean` explicitly declares a single bean, rather than letting Spring do it automatically.
2.  `@Component` is a class level annotation whereas `@Bean` is a method level annotation and name of the method serves as the bean name.
3.  `@Component` need not to be used with the `@Configuration` annotation where as `@Bean` annotation has to be used within the class which is annotated with `@Configuration`.

#### 9. `@Service`, `@Repository`
Помимо `@Component` в обоих аннотациях, в `@Repository` зашита обработка исключений. В `@Service` нет дополнительных функций, это просто маркер, что этот класс содержит бизнес-логику. 

#### 10. Differences between `applicationContext.xml` and `spring-servlet.xml` in Spring
In short, `applicationContext` is the central interface in Spring. It provides configuration information for an application. `spring-servlet.xml`is part of the Spring MVC framework. We declare in this file the component scans for controllers.

</details>

# Common question

#### 1. Для чего нужны системы контроля версий? 
Системы контроля версий сохраняют разные версии файлов. Это дает нам возможность просмотреть историю измения файла, а также вернуть состояние файла к предыдущей версии. 

#### 2. Виды систем контроля версий
* **Локальная VCS**. В БД хранятся записи обо всех изменениях файлов. Позволяет откатиться к предыдущим изменениям, но является абсолютно локальной, что неудобно при работе в команде. Примером является _RCS_.
* **Централизованная VCS**. Все изменения файлов хранятся на едином сервере. Упрощает коллективную работу, так как сервес с исходным кодом доступен нескольким людям, но в случаее неисправности сервера, весь исходный код будет утерян, так как хранится в единственном экземпляре только на сервере.   Примеры — CVS, Subversion(SVN), Perforce.
* **Распределенная VCS**. Хранение кода стало более надежным, так как он хранится у каждого локально, что позволяет его восстановить из любой локальной копии. Mercurial, Bazaar, Darcs и Git.        
    
#### 3. SVN vs Git
* Git распределенная система контроля версий, SVN централизованная
* Git сохраняет метаданные об изменениях файла, SVN сохраняет сами файлы. Git экономит место и получается рабтает быстрее
* В Git проще процесс сливания веток, в SVN сложнее, конфликты приходится разруливать руками
* SVN проще Git'а в освоении

# Git

#### 1.  Модели/стратегии ветвления в Git
**GitHub Flow**           
1. Код в ветке master должен быть всегда рабочим и готовым к развертыванию в любое время. 
2. При разработкеновой функциональности создается новая ветка от master-ветки и дается ей понятное, говорящее название. Разработка новой функциональности ведется только в этой новой ветке.
3. После того как функционал написан, открыть pull request, после ревью и апрува код мержится в master.
4. Новая версия мастера тут же должна быть развернута на сервере.               
                   
**GitFlow**
1. От master ветки создается ветка development в которой ведется разработка. Master по-прежнему остается всегда рабочим.
2. От development-ветки может быть создано три типа веток: feature-ветка (разработка новой фнкциональности), release-ветка (после написания функционала в этой ветке ведется подготовка к релизу новой версии приложения и устранению дефектов), hotfix-ветка (быстрое утсранение дефектов обнаруженных в проде самими пользователями). Все мержится сразу в development и только потом в master.           
                
**The Forking Workflow**                
Обычно применяется для open-source разработки. Сущетвует оригинальный репозиторий. Тот кто хочет внеси изменения в этот репозиторию делают форк репозитория, и работает в дрегом репозиториии. Владелец оригинального репозитория вправе отклонить предлагаемые изменения. Или смержить их в оригинальный репозиторий. 

#### 2. Основные состояния файлов
_измененный_, _индексированный_, _зафиксированный_    
      
_You are changed file_, _git add_, _git commit_
   
#### 3. Merge vs Rebase
Обе комманды предназначены для внесения изменений из одной ветки в другую, но делают они это по-разному.            
`git merge` объединяет несколько веток, история коммитов остается в первозданном виде, добавляется только коммит слияния.           
`git rebase` повторно применяет коммиты поверх другой базовой ветки. По сути создаются совершенно новые коммиты, хоть и идентичные по содержанию со старыми. Старые тем временем удаляются.             
            
* При merge мы решаем возникшие конфликты в одном коммите слияния. При rebase мы проходимся по каждому коммиту, и разрешаем конфликты в каждом коммите.
                 
Git merge:          
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-merge.png "merge")

Git rebase:             
(P.S. из ветки feature сделан rebase ветки main)            
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-rebase.png "rebase")

Еще про rebase.         
Как делать не надо (из ветки main сделан rebase ветки feature):         
![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/git-rebase-BAD-practice.png "так делать не надо")


#### 4. cherry-peak
Позволяет забрать коммит из одной ветку и вставить ее в текущую. 

#### 5. Как из нескольких коммитов сделать одни? 
`git squash`

#### 6. interactive rebase
Инструмент для исправления коммитов.

#### 7. `git stash` и `git stash applye`
`git stash` — откладывает изменения         
`git stash applye` — возвращает отложенные изменения

