#### 1. Иерархия Collection Framework

![](https://github.com/Primisen/interview/blob/master/pictures/collection-hierarchy.png "")
________________________________________________________________________________________________________

#### 2. Иерархия Map

![](https://github.com/Primisen/interview/blob/master/pictures/map-hierarchy.png "")

#### 3. Сложность операций

![](https://github.com/Primisen/interview/blob/master/pictures/%D0%BA%D0%BE%D0%BB%D0%BB%D0%B5%D0%BA%D1%86%D0%B8%D0%B8%2C%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9.png "")

## Map 

#### 4. Как устроен HashMap? 
Есть массив, каждый элемент которого называется бакетом. С помощью хэш-кода ключа вычисляется нужный бакет и в него ложится значение. Если бакет не пустой, то объекты в бакете сравниваются, если объекты одинаковые, то объект перезаписывается, если разные, то в бакет добавляется еще один элемент, образуя LinkedList, только односвязный, внутри бакета. Если размер односвязного списка превышает 8, то LinkedList трансформируется в TreeSet.  

Когда массив заполняется, он увеличивается вдвое и элементы перераспределяются. Начальный размер массива по умолчанию 16. Можно задать иной размер с помощью конструктора через параметр capacitycapacity

#### 5. HashMap, что будет если ключ будет изменяемым объектом?
Скорее всего мы потеряем значение, так как изменится hashCode ключа, и поэтому мы не сможем найти бакет, в который записали значение.

## Set

#### 6. HashSet
В основе используется HashMapб, с тем отличием, что в качестве ключа используется сам объект. 

#### 7. TreeSet
В основе лежит красно-черное дерево

#### 8. Какие должны быть выполнены условия для элемента чтобы его можно было добавить в TreeSet?
Судя по всему класс  должен имплементировать интерфейс Comparable

## Common

#### 9. `Comparable` vs `Comparator`

Эти два интерфейса нужны для сравнения объектов.
Разберем их отличия. 
__`Comparable`__
Есть интерфейс `Comparable` у которого есть метод `compareTo(T o)`. Реализуя этот метод в классе мы получаем 
возможность сравнивать между собой экземпляры этого класса. Этим методом пользуются некоторые коллекции, которые хранят элементы в отсортированном виде, как я понимаю.
Правила переопределения метода `compateTo(T o)` следующие:
* если объекты равны, то возвращаем 0
* если первый объект (на котором вызывается метод) больше чем второй, то возвращаем 1
* если первый объект меньше второго, то возвращаем -1

__`Comparator`__
Этот интерфейс реализовывается отдельным классом, который будет сравнивать два объекта одного класса. У интерфейса `Comparator` есть метод 
`compare(T o1, T o2)` в котором мы должны описать алгоритм сравнения (правила переопределения такие же как у compareTo(T o)). Дальше мы создаем экземпляр
этого класса-сравнителя и закидываем в метод сортировки коллекции. 


#### 10. `Iterable` vs `Iterator`
Если какой-либо класс реализует `Iterable` интерфейс, он получает возможность перебирать объект этого класса, используя `Iterator`. `Iterable` представляет коллекцию, которую можно обойти. Реализация `Iterable` позволяет объекту использовать цикл for-each. Он делает это внутренне вызывая метод `iterator()` на объекте.
