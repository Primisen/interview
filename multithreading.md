#### 1. Состояния потоков.
*  __NEW__ - поток создан, но метод `start()` еще не вызван.
*  __RUNNING__ - метод `start()` вызван, поток что-то делает.
*  __TERMINATED__ - поток завершил работу, но еще жив.
*  __BLOCKED__ - поток может быть заблокирован. Например при входе в блок `synchronized`. Поток подошел к такому блоку, а в этот блок уже зашел другой поток. Тогда поток получит это сотояние.
*  __WAITING__ - поток ждет, например при вызове метода `join()` или `wait()`
*  __TIMED_WAITING__ 

_Пометочка (актуальна для одноядерного процессора):_ в каждый момент времени работает только один поток. А видимая одновременная работа —  это постоянное перескакивание процессора с потока на поток. Для времени когда поток 
как бы работает, а на самом деле ждет своей очереди, тоже есть отдельное состояние. Оно называется `ready-to-run`. Поток постоянно меняет состояние с `running` на `ready` и 
потом снова на `running` когда становится активной.

#### 2. `Volatile`
Потоки могут кэшировть переменные. Может возникунть ситуация когда один поток изменил переменную, а второй поток этого не заметил, потому что работал с закэшированной переменной. Будет беда.  
Для того чтобы потоки не смогли кэшировать переменную, ее помечают модификатором `volatie`.   
Также этот модификатор гарантирует что операции с переменной будут атомарны, например с переменными типа long и double, операции с которыми проиходят в две команды (32 bit и 32 bit)

#### 3. Если у нас какое-нибудь поле int, и мы на него повесили `volatile`, этого достаточно чтобы переменная стала потокобезопасной?
Нет, еще нужен `synchronized`

#### 4. `Synchronized`
Блок кода, который помечен как `synchronized`, одновременно доступен только одному потоку.
Synchronized метод или synchronized блок? Как я понимаю, synchronized метод лучше по произодительности, потому что байт код синхронизированного метода выполняет меньшее количество операций, чем байт код синхронизированного блока.

#### 5.  Что такое процесс и поток?
Процесс - это, как правило, одна программа (хотя есть и исключения, например Chrome, который создает процесс на каждую вкладку). Процесс занимает определенную область памяти компьютера. Процессы изолированы друг от друга. Процесс может содержать несколько потоков, который выполняет определенный блок кода. Процесс всегда имеет как минимум один поток.

#### 6. Где может применяться многопоточность? 
Например, при создании пользовательского интерфейса. Пока скачивается файл из интернета в одном потоке, другой поток крутит аннимацию загрузки или может остановить первый поток, если пользователь нажал кнопку "отмена". Многопоточность широко используется в играх.

#### 7. Способы создания потока. 
1. Через интерфейс `Runnable`   
Необходимо создать класс, который имплементирует интерфейс `Runnable` и переопределить метод этого интерфейса `run()`, в котором нужнно описать что будет делать этот поток. Поток закончит свое выполнение, если завершится метод `run()`. Далее нужно экземпляр этого класса передать в конструктор экземпляра класса `Thread`.   
Для сокращения кода можно в конструктор класса Thread передать объект безымянного внутреннего класса, который реализует интерфейс Runnable.   
2. Череез наследование от класса `Thread`
Нужно создать класс, который унаследутся от класса `Thread` и переопределит его метод `run()`.   



Чтобы запустить поток необходимо вызвать на нем метод `start()`.

#### 8. Что такое поток демон?
В Java процесс завершается тогда, когда выполнился его последний поток. Но это не касается потока демона. Если выполнились основные потоки, но не выполнился поток демон, тогда процесс завершается, а работа потока демона обрывается. 

#### 9. Как из обычного потока сделать поток демон? 
`setDaemon(true)`

#### 10. Как проверть, является ли  поток потоком демоном? 
`boolean isDaemon()`

#### 11. Как остановить поток? 
1. По завершению метода run() (main() для главного потока) поток завершит свою работу.   
Тут все понятно.
2. По сигналу из друго потока.   
Поток, которого попросил остановиться другой поток, может выполнить еще некоторые операции и завершиться или проигнорировать сообщение вовсе. Тут как решит разработчик потока. 

_Методы потока `stop()`, `suspend()`, `resume()` объявлены deprecated и нежелательны к использованию. Потому что эти методы внезапно прерывают поток, а это может вести к множеству пролем (неправильные данные(поток не успел закончить их обрабатывать и закнчил операции на середине), трудно отлавливаемые ошибки)._

#### 12. `interrupt()`
При вызове этого метода у потока меняется статус на то, что он прерван. При этом это не значит, что поток остановит свою работу, он просто поменял статус. Сам метод возвращает true, если поток может быть прерван, иначе false.   
Чтобы проверить статус можно вызвать метод `isInterrupted()`, которые вернет true, если поток может быть прерван.

#### 13. `Thread.sleep()`
Поток ждет заданное количество времени.

#### 14. `Thread.yield()`
Поток приостанавливается и говорит что сейчас могут поработать другие потоки.
Полезен если поток может сказать: "мне нужно кое что подождать чтобы продлжить работу, так что пусть пока поработают другие потоки".

#### 15. `join()`
Позволяет потоку ждать завершения другого потока.   
_Как использовать._ Например, один поток должен подождать пока завершится поток someThread. Для этого в нашем потоке нужно вызвать `someThread.join()`.

#### 16. Runnable vs Collable
| Runnable | Collable |
| --- | --- | 
| `run()` | `call()` |
....other

#### 17. Основные проблемы многопоточности.
* Состояние гонки   
Проблема возникает если работа программы зависит от того в каком порядке выполняются потоки. К примеру, два потока одновременно работают с одними и теми же данными, скорее всего произойдет так, что изменения какого-то потока будут затерты и запишутся изменения только одного потока или подобные ошибки. Хотя мы ожидали, что потоки выолнятся последовательно и изменения сделанные двумя потоками "просуммируются".   
Решить эту проблему можно с  помощью атомиков или синхронизировать данные.
* Deadlock   
Взаимная блокировка. Это когда один поток ждет данные из другого потока чтобы продолжить работу, в это же самое время другой поток ждет результат первого потока, чтобы продолжить совю работу, поэтому ни один поток не может продолжить работу, так как они ждут результат выполнения друг друга.
* Livelock   
Возникает когда работа одного потока является ответ на работу другого потока, а работа второго на работу первого. Они не блакируются, они пытаются продолжать свою работу, но делают это бесконечно.
* Starvation   
Голодание потоков. Когда потоку нужны определенные данные, но он не может к ним достучаться потому что всегда отдается предпочтение другим потокам.

#### 18. Мьютекс, монитор, семафор
__Мьютекс__ - это специальный объект для синхронизации потоков. Он прикреплен к каждому объекту Java. Задачей мьютекса является обеспечить такой механизм, чтобы доступ к объекту был только у одного потока. 
* У мьютекса возможны только два состояния: свободен и занят.
* Мьютексом нельзя управлять напрямую, доступ к объекту мьютекса есть только у джава машины.   



__Монитор__ - это надстройка над мьютексом. Смотри слово `synchronized` означает какие-то определенные команды, определенный блок кода, который, скажем так, для разработчика объявлен неявно, то есть скрыт под эти словом. Все эти команды в synchronized по сути и являются монитором. Как я понимаю, монитор это реализация мьютекса, то есть это что-то определенное, что не дает зайти в наш кусок кода более чем одному потоку.   



__Семафор__. То же же что и монитор, но со счетчиком. То есть если монитор может впускать в код только один поток, то семафор столько потоков, сколько выставлено у него в счетчике.   

# Cuncurrent
Потокобезопасные коллекции

#### 1. Атомики
С точки зрения программиста операция i++ атомарна. С точки зрения JVM нет. Для выполнения операции i++ JVM необходимо выполнить три действия: прочитаь значение i, добавить к нему единицу, записать новое значение. В многопоточной среде это может вызвать проблемы, так как пока один поток занят инкрементацией переменной, второй поток может прочитать промежуточное значение переменной. Это можно решить с помощью ключевого слова `synchronized`, но оно ест много производительности тем более проявляет блокировку, когда с переменной может работать только один поток. Поэтому решили создать атомики, которые производительнее по сравнению с `synchronized` и используют механизм _оптимистичной блокировки_. Оптимистичная блокировка заключается в том, что данные доступны любому потоку, но если поток обнаружил, что данные были изменены другим потоком, он их обнавляет и работает с обнавленными данными. На этом подходе работают атомарные классы.



Основные атомарные классы:
* AtomicLong
* AtomicInteger
* AtomicBoolean
* AtomicReference



_Основные методы атомиков._ 
* `compareAndSet()`. Принимает два значения: предполагаемое текущее и новое значение. Метод установит новое значение, если текущее значение равно предполагаемому и возвращает true. Если текущее значение изменилось, то метод вернет false и новое значение не будет установлено.
* `getAndSet()`. Безусловно устанавливает новое значение и возвращает старое.
* AtomicInteger и AtomicLong имеют также методы инкремента/декремента/добавления нового значения.   


# JMM

#### 1. Устройство памяти Java
Модель памяти Java, используемая внутри JVM, делит память на стеки потоков и кучу. 

![alt-текст](https://github.com/Primisen/interview/blob/master/pictures/jvm%2C%20jmm.png "")   

У каждого потока свой стек, при этом данные у каждого стека свои, которые не видны другому стеку. Например, если два потока работают с одним и тем же методом, то у каждого потока в стеке будут свои локальные переменные из этого метода, которые будут недоступны другому стеку.
