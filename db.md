#### 1. Что такое ACID и за счет чего обеспечивается каждое правило?
+ __Атомарность__ означает что транзакция или выполнится полностью, или не выполнится вообще. Не будет так, что часть команд транзакции выполнится, а другая часть нет. Обеспечивается с помощью rollback(система откатится до предыдущего состояния)
+ __Согласованность__ - значит что данные сохраняют свою целостность, логичность, что они будут находиться в таком виде, в каком задумывалась.  Обеспечивается самим разработчиком
+ __Изолированность__ - означает что все транзакции выполняются изолированно друг от друга, то есть одна транзакция не сможет прочить/использовать данные другой транзакции. Это гарантируется уровнями изолированности
+ __Надеждность__ - даже если что-то произошло с устройством, где выполнилсь транзакции, после починки БД останется в исходном состоянии без изменений. Обеспечивается с помощью журнала транзакций

#### 2. Журнал транзакций
СУБД сохраняет информацию для восстаовления БД для случаев логических или физических сбоев.
Если конкретнее, то в последоватльном порядке записываются все изменения, происходившие с БД.

#### 3. Уровни изоляции транзакций

|Уровень изоляции|Фантомное чтение|Неповторяющееся чтение|"Грязное" чтение|Потерянное обновление|
|---|---|---|---|---|
|__SERILIZABLE__|+|+|+|+|
|__REPEATABLE READ__ (MySQL)|-|+|+|+|
|__READ COMMITTED__ (PostgreSQL)|-|-|+|+|
|__READ UNCOMMITTED__|-|-|-|+|

__READ UNCOMMITED__ (самая низкая согласованность, самая высокая производительность)    
__READ COMMITED__         
__REPEATABLE READ__        
__SERIALIZABLE__ (самая высокая согласованность, самая низкая производительность) - две транзакции в обсолютной изоляции друг от друга.     

#### 4. Проблемы параллельного выполнения транзакций
+ __Фантомное чтение__ - одна транзакция выбирает значения по некоторому _условию_ и получила один результат. Потом, вторая транзакция добавляет данные, которые соответсвуют этому условию. Первая транзакция повторяет чтение, и получает данные, которых раньше не было, то есть _другое количество строк_.   
+ __Неповторяющееся чтение__ - транзакция прочитала данные один раз и получила один результат. Потом снова прочитала, но получила другие данные. Все дело в том, что вторая транзакция изменила данные во время работы первой. Различие с фантомным чтением в том, что здесь не изменяется количество строк, _изменились_ только _существующие данные_.     
+ __"Грязное" чтение__ - также одна транзакция изменяет данные, вторая читает. Первая транзакция изменила данные, вторая считала эти данные. Первая транзакция откатила свои изменения. Вторая транзакция продолжает работать с измененными неактуальными значениями. 
+ __Потерянное обновление__ - две транзакции одновременно изменяют одни и те же данные. Исходные данные у обоих транзакций были одинаковые, а в итоге в БД запишутся изменения той транзакции, которая закончила работу последней.

#### 6. `HAVING` vs `WHERE`
`HAVING` аналогичен `WHERE` с единственным отличием что он используется для групп.
 
#### 7. Можно  ли использовать HAVING без WHERE?
Можно.

#### 8. Назовите агрегатные функции в SQL.
SUM, MIN, MAX, AVG, COUNT

#### 9. Что такое SQL инъекции? 
Когда мы можем в SQL запрос внедрить SQL команды, который приведут к неправильному поведению программы

#### 9. Cложность поиска по индексу
Логарифмическая `O(log(n))`

#### 9. Виды связей между таблицами в реляционной БД. Как реализуются эти связи? 
* Один к одному (Уникальное значение ссылается на другое уникальное значение. Например, когда таблицы связаны по первичным ключам)
![](https://github.com/Primisen/interview/blob/master/pictures/one-to-one.png)
* Один ко многим (Наиболее часто встречающеея отношение. Когда уникальное значение связано с неуникальным столбцом, то есть одной запсии соответсвует несколько других из другой таблицы)
* Многие ко многим

#### 10. Нормализация БД (первые три нормальные формы)
**1.** Нет повторяющихся строк. Каждое поле таблицы содержит одно значение, то есть нет перечислений значений через запятую      

**Плохо:**       
|Фирма|Модели|
|---|---|
|BMW|M5, X5M, M1|
|Nissan|GT-R|
|Nissan|GT-R|
      
**Хорошо:**       
|Фирма|Модели|
|---|---|
|BMW|M5|
|BMW|X5M|
|BMW|M1|
|Nissan|GT-R|

**2.** Соблюдение 1-ой нормальной формы. Каждый неключевой элемент логически зависит от первичного ключа. Иначе выносим в отдельную таблицу       
       
**Плохо:**        
|Модель|	Фирма|	Цена|	Скидка |
|---|---|---|---|
|M5|	BMW	| 5500000	| 5%|
|X5M|	BMW	| 6000000	| 5%|
|M1|	BMW	| 2500000	| 5%|
|GT-R|	Nissan |	5000000|	10%|
       
**Хорошо:**
|Модель |	Фирма |	Цена |
|---|---|---|
|M5	| BMW	| 5500000|
|X5M	| BMW	| 6000000|
|M1	| BMW	| 2500000|
|GT-R	| Nissan	| 5000000|
       
|Фирма|	Скидка|
|---|---|
|BMW|	5%|
|Nissan|	10%|

**3.** Соблюдение первой и второй нормальных форм. Неключевые столбцы не должны зависеть от других неключевых столбцов (такая зависимость называется транзитиной)        
      
**Плохо:**       
|Модель|	Магазин|	Телефон|
|---|---|---|
|BMW	| Риал-авто	|87-33-98|
|Audi	| Риал-авто	|87-33-98|
|Nissan|	Некст-Авто	|94-54-12|
       
**Хорошо:**     
|Магазин	| Телефон|
|--|--|
|Риал-авто|	87-33-98|
|Некст-Авто|	94-54-12|
      
|Модель|	Магазин|
|--|--|
|BMW	| Риал-авто|
|Audi|	Риал-авто|
|Nissan|	Некст-Авто|
       
#### 11. Масштабирование БД
Применяется в высоконагруженных системах.       
Что делать, когда данные перестают влезать на один сервер? Есть два стандартных механизма масштабирования:      
**Вертикальное**, когда мы просто добавляем в этот сервер память и диски. Это имеет свои пределы — по количеству ядер на процессор, количеству процессоров, объему памяти.          
**Горизонтальное**, когда мы используем много машин и распределяем данные между ними. Наборы таких машин называются кластерами. Чтобы поместить данные в кластер, их нужно шардировать — то есть для каждой записи определить, на каком конкретно сервере она будет размещена.       
      
#### 12. Виды индексов БД
* _Кластеризованный._ Хранит значения в отсортированном порядке: по возрастанию/убыванию, поэтому может быть только один. В листьях дерева хранит конкретные значения, а не ссылку на них.
* _Некластеризованный._ Хранит в листьях дерева ссылку на реальные значения.
* _Составной._ Такой индекс может содержать более одного столбца (до 16 столбцов). Может быть как кластеризованнм, так и не кластеризованным. 
* _Уникальный._ Такой индекс гарантирует уникальность каждого значения в индексируемом столбце.
* _Покрывающий._ Позволяет получить все данные строки без дополнительного обращения к БД.

#### 9. Нереляционные базы данных

#### 10. Как мне объединить два запроса? 

#### 11. Какой уровень изоляции в MySQL и PostreSQL по умолчанию?
MySQL - REPEATABLE READ        
PostgreSQL - READ COMMITED     

#### 14. Таблица View в БД
Таблица в которой хранятся сохраненный SELECT запросы

#### 15. Тип SERIAL
Тип данных SERIAL хранит последовательное целое число типа данных INT, которое автоматически назначается сервером базы данных при вставке новой строки. Серийный начальный номер по умолчанию равен 1, но вы можете назначить начальное значение n при создании или изменении таблицы.
